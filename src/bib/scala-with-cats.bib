@inproceedings{10.1145/325694.325708,
author = {Lewis, Jeffrey R. and Launchbury, John and Meijer, Erik and Shields, Mark B.},
title = {Implicit parameters: dynamic scoping with static types},
year = {2000},
isbn = {1581131259},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/325694.325708},
doi = {10.1145/325694.325708},
abstract = {This paper introduces a language feature, called implicit parameters, that provides dynamically scoped variables within a statically-typed Hindley-Milner framework. Implicit parameters are lexically distinct from regular identifiers, and are bound by a special with construct whose scope is dynamic, rather than static as with let. Implicit parameters are treated by the type system as parameters that are not explicitly declared, but are inferred from their use.We present implicit parameters within a small call-by-name λ-calculus. We give a type system, a type inference algorithm, and several semantics. We also explore implicit parameters in the wider settings of call-by-need languages with overloading, and call-by-value languages with effects. As a witness to the former, we have implemented implicit parameters as an extension of Haskell within the Hugs interpreter, which we use to present several motivating examples.},
booktitle = {Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {108–118},
numpages = {11},
location = {Boston, MA, USA},
series = {POPL '00}
}

@inproceedings{10.1145/75277.75283,
author = {Wadler, P. and Blott, S.},
title = {How to make ad-hoc polymorphism less ad hoc},
year = {1989},
isbn = {0897912942},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/75277.75283},
doi = {10.1145/75277.75283},
abstract = {This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the “eqtype variables” of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules.},
booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {60–76},
numpages = {17},
location = {Austin, Texas, USA},
series = {POPL '89}
}

@InProceedings{10.1007/3-540-19027-9_9,
author="Kaes, Stefan",
editor="Ganzinger, H.",
title="Parametric overloading in polymorphic programming languages",
booktitle="ESOP '88",
year="1988",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="131--144",
abstract="The introduction of unrestricted overloading in languages with type systems based on implicit parametric polymorphism generally destroys the principal type property: namely that the type of every expression can uniformly be represented by a single type expression over some set of type variables. As a consequence, type inference in the presence of unrestricted overloading can become a NP-complete problem. In this paper we define the concept of parametric overloading as a restricted form of overloading which is easily combined with parametric polymorphism. Parametric overloading preserves the principal type property, thereby allowing the design of efficient type inference algorithms. We present sound type deduction systems, both for predefined and programmer defined overloading. Finally we state that parametric overloading can be resolved either statically, at compile time, or dynamically, during program execution.",
isbn="978-3-540-38941-5"
}

@inproceedings{10.1145/1869459.1869489,
author = {Oliveira, Bruno C.d.S. and Moors, Adriaan and Odersky, Martin},
title = {Type classes as objects and implicits},
year = {2010},
isbn = {9781450302036},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1869459.1869489},
doi = {10.1145/1869459.1869489},
abstract = {Type classes were originally developed in Haskell as a disciplined alternative to ad-hoc polymorphism. Type classes have been shown to provide a type-safe solution to important challenges in software engineering and programming languages such as, for example, retroactive extension of programs. They are also recognized as a good mechanism for concept-based generic programming and, more recently, have evolved into a mechanism for type-level computation.This paper presents a lightweight approach to type classes in object-oriented (OO) languages with generics using the CONCEPT pattern and implicits (a type-directed implicit parameter passing mechanism). This paper also shows how Scala's type system conspires with implicits to enable, and even surpass, many common extensions of the Haskell type class system, making Scala ideally suited for generic programming in the large.},
booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
pages = {341–360},
numpages = {20},
keywords = {abstract datatypes, c++ concepts, scala, type classes},
location = {Reno/Tahoe, Nevada, USA},
series = {OOPSLA '10}
}

@inproceedings{10.1145/99370.99404,
author = {Wadler, Philip},
title = {Theorems for free!},
year = {1989},
isbn = {0897913280},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/99370.99404},
doi = {10.1145/99370.99404},
booktitle = {Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture},
pages = {347–359},
numpages = {13},
location = {Imperial College, London, United Kingdom},
series = {FPCA '89}
}

@article{10.1145/3360589,
author = {K\v{r}ikava, Filip and Miller, Heather and Vitek, Jan},
title = {Scala implicits are everywhere: a large-scale study of the use of Scala implicits in the wild},
year = {2019},
issue_date = {October 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
url = {https://doi.org/10.1145/3360589},
doi = {10.1145/3360589},
abstract = {The Scala programming language offers two distinctive language features implicit parameters and implicit conversions, often referred together as implicits. Announced without fanfare in 2004, implicits have quickly grown to become a widely and pervasively used feature of the language. They provide a way to reduce the boilerplate code in Scala programs. They are also used to implement certain language features without having to modify the compiler. We report on a large-scale study of the use of implicits in the wild. For this, we analyzed 7,280 Scala projects hosted on GitHub, spanning over 8.1M call sites involving implicits and 370.7K implicit declarations across 18.7M lines of Scala code.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {163},
numpages = {28},
keywords = {Implicit parameters, Scala, corpora analysis, implicit conversions}
}

@article{OLIVEIRA_GIBBONS_2010
, title={Scala for generic programmers: Comparing Haskell and Scala support for generic programming}
, volume={20}
, DOI={10.1017/S0956796810000171}
, url={https://www.cambridge.org/core/journals/journal-of-functional-programming/article/scala-for-generic-programmers/223EB37E77EA36B27AE33A644DA70926}
, number={3–4}
, journal={Journal of Functional Programming}
, author={Oliveira, Bruno C. D. S. and Gibbons, Jeremy}
, year={2010}
, pages={303–352}
}

@article{10.1145/3158130,
author = {Odersky, Martin and Blanvillain, Olivier and Liu, Fengyun and Biboudis, Aggelos and Miller, Heather and Stucki, Sandro},
title = {Simplicitly: foundations and applications of implicit function types},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158130},
doi = {10.1145/3158130},
abstract = {Understanding a program entails understanding its context; dependencies, configurations and even implementations are all forms of contexts. Modern programming languages and theorem provers offer an array of constructs to define contexts, implicitly. Scala offers implicit parameters which are used pervasively, but which cannot be abstracted over. This paper describes a generalization of implicit parameters to implicit function types, a powerful way to abstract over the context in which some piece of code is run. We provide a formalization based on bidirectional type-checking that closely follows the semantics implemented by the Scala compiler. To demonstrate their range of abstraction capabilities, we present several applications that make use of implicit function types. We show how to encode the builder pattern, tagless interpreters, reader and free monads and we assess the performance of the monadic structures presented.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {42},
numpages = {29},
keywords = {implicit parameters, Scala, Dotty}
}
