# Reified Interpreters

In the previous chapter we learned about algebraic data types. In this chapter we'll learn one of their major use cases, implementing interpreters. The interpreter strategy is perhaps the most important in all of functional programming.

Before discussing the code, let's talk about why we might want to implement an interpreter.  Implementing an interpreter sounds like a fairly esoteric thing to do, but it forms the core for building systems that maintain the desirable properties of functional programming---compositionality and reasoning---while allowing us to have effects in our code. The central idea is to **separate description from action**. For example, imagine we're implementing a graphics library using the interpreter strategy. A description simply says what we want to draw on the screen, but critically it does not actually draw anything. The interpreter takes this description and carries out the actions described by it. As the description doesn't do anything, we can freely compose descriptions. For example, if we have a description that describes a circle, and one for a square, we can compose them by saying we should draw the circle next to the square. This creates a new description that is the composition of the two base descriptions.

It may be hard to see how this works from an abstract description. We'll make it concrete in just a moment, by building an interpreter for regular expressions. We've chosen this example because regular expressions are hopefully familiar to most you, so we can concentrate on the interpreter strategy and not on the details of regular expressions. We'll them extract the general strategy from this specific example, and finally give a few pointers to learn more.
