## Validateds

Let's look now at another example---using applicatives for error handling.

Cats provides two types for error handling: `Xor` and a new type called `Validated`.
We've met `Xor` already---it is a monad that provides fail-fast error handling semantics.
In the following example, we never call `fail2` because `fail1` returns and error:

```tut:book
type ErrorOr[A] = List[String] Xor A

def fail1: ErrorOr[Int] = {
  println("Calling fail1")
  List("Fail1").left
}

def fail2: ErrorOr[Int] = {
  println("Calling fail2")
  List("Fail2").left
}

for {
  a <- fail1
  b <- fail2
} yield a + b
```

The `Xor` type is an applicative as well as a monad. However, the definition of `ap` is written in terms of `flatMap` so we get the same fail-fast semantics:

```tut:book
Applicative[ErrorOr].apply2(fail1, fail2)(_ + _)
```

Fail-fast is not always the correct type of error handling. Imagine validating a web form: we want to check all validation rules and return all errors we find. Cats models this cumulative style of error handling with a different type called `Validated`. `Validated` is an `Applicative` but not a `Monad`. It accumulates errors on failure:

```tut:book
type ErrorOr[A] = Validated[List[String], A]

def fail1: ErrorOr[String] = {
  println("Calling fail1")
  List("Fail1").failure
}

def fail2: ErrorOr[Int] = {
  println("Calling fail2")
  List("Fail2").failure
}

Applicative[ErrorOr].apply2(fail1, fail2)(_ + _)
```

`Validated` uses a `Semigroup` to accumulate errors. Remember that a `Semigroup` is the `append` operation of a `Monoid` without the `zero` component. Here are a few concrete examples:

```tut:book
// Types of Validated:
type StringOr[A] = Validated[String, A]
type ListOr[A]   = Validated[List[String], A]
type VectorOr[A] = Validated[Vector[Int], A]

Applicative[StringOr].apply2(
  "Hello".failure[Int],
  "world".failure[Int]
)(_ * _)

Applicative[ListOr].apply2(
  List("Hello").failure[Int],
  List("world").failure[Int]
)(_ * _)

Applicative[VectorOr].apply2(
  Vector(404).failure[Int],
  Vector(500).failure[Int]
)(_ * _)
```

### Validated Methods and Syntax

`Validated` has two subtypes, `Success` and `Failure`, that correspond loosely to the `Right` and `Left` subtypes of `Either`:

```tut:book
import cats.{ Validated, Success, Failure }

val s: Validated[String, Int] = Success(123)

val f: Validated[String, Int] = Failure("message")
```

We can import enriched `success` and `failure` methods from `cats.syntax.validation` to simplify construction:

```tut:book
import cats.syntax.validation._

123.success[String]

"message".failure[Int]
```

The enriched `parseInt` method we saw in exercises for `Xor` is available from `cats.syntax.std.string`. It returns a `Validated[NumberFormatException, Int]`:

```tut:book
"123".parseInt
```

We can convert back and forth between `Validated` and `Xor` using the `disjuction` and `validation` methods. This allows us to switch between fail-fast and error-accumulating semantics on the fly:

```tut:book
"123".parseInt.disjunction
// re

"123".parseInt.disjunction.validation
```

We can `map`, `leftMap`, and `biMap` to transform the success and failure values in a `Validated`, just as we can to transform the left and right values in a disjunction:

```tut:book
123.success.map(_ * 100)

456.failure.leftMap(_.toString)

123.success[String].bimap(_ + "!", _ * 100)

"fail".failure[Int].bimap(_ + "!", _ * 100)
```

Finally, we can `getOrElse` or `fold` on a `Validated` to extract the values:

```tut:book
"fail".failure[Int].getOrElse(0)

"fail".failure[Int].fold(_ + "!!!", _.toString)
```

### Exercise: Form Validated

We want to validate an HTML registration form. We receive request data from the client in a `Map[String, String]` and want to parse it to create a `User` object:

```tut:book
case class User(name: String, age: Int)
```

Our goal is to implement code that parses the incoming data enforcing the following rules:

 - the name and age must be specified;
 - the name must not be blank;
 - the the age must be a valid non-negative integer.

If all the rules pass our parser we should return a `User`. If any rules fail, we should return a `List` of the error messages.

Let's model this using the `Validated` data type. The first step is to determine an error type and write a type alias called `Result` to help us use `Validated` with `Applicative`:

<div class="solution">
The problem description specifies that we need to return a `List` of error messages in the event of a failure. `List[String]` is a sensible type to use to report errors.

We need to fix the error type for our `Validated` to create a type constructor with a single parameter that we can use with `Applicative`. We can do this with a simple type alias:

```tut:book
type Result[A] = Validated[List[String], A]
```
</div>

Now define two methods to read the `"name"` and `"age"` fields:

 - `readName` should take a `Map[String, String]` parameter, extract the `"name"` field, check the relevant validation rules, and return a `Result[String]`;

 - `readAge` should take a `Map[String, String]` parameter, extract the `"age"` field, check the relevant validation rules, and return a `Result[Int]`.

Tip: Use the `parseInt` and `leftMap` methods described in the previous section to parse the age as an `Int`.

<div class="solution">
Here are the methods:

```tut:book
def readName(data: Map[String, String]): Result[String] =
  data.get("name").map(_.trim) match {
    case None       => List("No name specified").failure
    case Some("")   => List("Name cannot be blank").failure
    case Some(name) => name.success
  }

def readAge(data: Map[String, String]): Result[Int] =
  data.get("age").map(_.trim) match {
    case None            => List("No age specified").failure
    case Some("")        => List("Age cannot be blank").failure
    case Some(ageString) => ageString.parseInt match {
      case Failure(exn)            => List("Age must be a number").failure
      case Success(num) if num < 0 => List("Age must not be negative").failure
      case Success(num)            => num.success
    }
  }
```
</div>

Finally, use an `Applicative` to combine the results of `readName` and `readAge` to produce a `User`:

<div class="solution">
There are several ways to do this. One option is to use `apply2`:

```tut:book
def readUser(data: Map[String, String]): Result[User] =
  Applicative[Result].apply2(readName(data), readAge(data))(User.apply)

readUser(Map("name" -> "Dave", "age" -> "36"))

readUser(Map("age" -> "-1"))
```

Alternatively, we can use the applicative builder syntax for identical semantics but slightly shorter code:

```tut:book
def readUser(data: Map[String, String]): Result[User] =
  (readName(data) |@| readAge(data))(User.apply)
```
</div>
