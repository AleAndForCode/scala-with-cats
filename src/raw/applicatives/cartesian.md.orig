<<<<<<< HEAD
## *Cartesian* {#cartesian}

`Cartesian` is a type class that allows us to "zip" values within a context.
If we have two objects of type `F[A]` and `F[B]`,
a `Cartesian[F]` allows us to zip combine them to form an `F[(A, B)]`.
Its definition in Cats is:
=======
## The *Cartesian* type class

`Cartesian` is a type class that allows us to "zip" values.
If we have two objects of type `F[A]` and `F[B]`,
a `Cartesian[F]` allows us to zip combine them to form an `F[(A, B)]`.

The definition of Cartesian in Cats is:
>>>>>>> bb2bfe4b083eae865dbfbf6d8b88eaa174851e73

```scala
trait Cartesian[F[_]] {
  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]
}
```

<<<<<<< HEAD
The intuition is that `product`
combines the results of *independent* computations.
This is in contrast to `flatMap`,
which combines the results of *dependent* computations.

=======
>>>>>>> bb2bfe4b083eae865dbfbf6d8b88eaa174851e73
### Combining *Options*

Let's see this in action.
The code below summons a `Cartesian` for `Option`
and uses it to zip two values:

```tut:book
import cats.Cartesian
import cats.instances.option._

Cartesian[Option].product(Some(123), Some("abc"))
```

<<<<<<< HEAD
If either or both of the argument values is `None`,
=======
In the case of `Option`,
if either or both of the argument values is `None`,
>>>>>>> bb2bfe4b083eae865dbfbf6d8b88eaa174851e73
the result is always `None`:

```tut:book
Cartesian[Option].product(None, Some("abc"))
Cartesian[Option].product(Some(123), None)
```

### Combining *Futures*

The semantics of `product` are, of course, different for every data type.
<<<<<<< HEAD
For example, the `Cartesian` for `Future`
zips the results of asynchronous computations:
=======
For example, the `Cartesian[Future]` combines `Futures` in parallel:
>>>>>>> bb2bfe4b083eae865dbfbf6d8b88eaa174851e73

```tut:book
import scala.concurrent._
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration

import cats.instances.future._

val future = Cartesian[Future].product(Future(123), Future("abc"))

Await.result(future, Duration.Inf)
```

<<<<<<< HEAD
The example above illustrates nicely what we mean
by combining the results of *independent* compuatations.
The two `Futures`, `Future(123)` and `Future("abc")`,
are started independently of one another and execute in parallel.
This is in contrast to monadic combination, which executes them in sequence:

```tut:book
val future = for {
  a <- Future(1)
  b <- Future(2)
} yield (a, b)
```

In fact, for consistency, Cats implements the `product` method
for all monadic data types in the same way: in terms of `flatMap`:

```scala
def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
  for {
    a <- fa
    b <- fb
  } yield (a, b)
```

This means our `product` example above is semantically identical
to the conventional approach for combining parallel compuatations in Scala:
create the `Futures` first and combine the results using `flatMap`:

```tut:book
// Start the futures in parallel:
val fa = Future(123)
val fb = Future("abc")

// Combine their results using flatMap:
val future = for {
  a <- fa
  b <- fb
} yield (a, b)
```

=======
>>>>>>> bb2bfe4b083eae865dbfbf6d8b88eaa174851e73
### Combining *Xors*

When combining `Xors`, we have to use a type alias to fix the left hand side:

```tut:book
import cats.data.Xor

type ErrorOr[A] = List[String] Xor A

Cartesian[ErrorOr].product(
  Xor.right(123),
  Xor.right("abc")
)
```

<<<<<<< HEAD
If we try to combine successful and failed `Xors`,
the `product` method returns the errors from the failed side:
=======
If we try to combine failed and successful `Xors`,
the `product` method returns the errors from the failed parameter:
>>>>>>> bb2bfe4b083eae865dbfbf6d8b88eaa174851e73

```tut:book
Cartesian[ErrorOr].product(
  Xor.left(List("Fail parameter 1")),
  Xor.right("abc")
)

Cartesian[ErrorOr].product(
  Xor.right(123),
  Xor.left(List("Fail parameter 2"))
)
```

<<<<<<< HEAD
Surprisingly, if *both* sides are failures, only the left-most errors are retained:
=======
However, if *both* sides are failures,
only one set of errors is retained:
>>>>>>> bb2bfe4b083eae865dbfbf6d8b88eaa174851e73

```tut:book
Cartesian[ErrorOr].product(
  Xor.left(List("Fail parameter 1")),
  Xor.left(List("Fail parameter 2"))
)
```

<<<<<<< HEAD
If you think back to our examples regarding `Futures`,
you'll see why this is the case.
`Xor` is a monad, so Cats implements `product` in terms of `flatMap`.
As we saw at the beginning of this chapter,
`flatMap` implements fail-fast error handling
so we can't use `Xor` to accumulate errors.

Fortunately there is a solution to this problem.
Cats provides another data type called `Validated` in addition to `Xor`.
`Validated` is a `Cartesian` but it is not a `Monad.
This means Cats can provide an error-accumulating implementation of `product`
without introducing inconsistent semantics.

`Validated` is an important data type,
so we will cover it separately and extensively later on this chapter.
=======
Why does this happen? It seems counter-intuitive.
The reason is that `Xor` is a monad.
The designers of Cats decided to keep
the definitions of `product` and `flatMap` consistent for all monads
by defining the one in terms of the other:

```scala
def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
  for {
    a <- fa
    b <- fb
  } yield (a, b)
```

To retain errors from both sides,
we have to use a different data type called `Validated`.
`Validated` is very similar to `Xor`,
except it isn't a `Monad`
and its `Cartesian` and `Applicative` instances retain all errors.
We will look at `Validated` in more detail later in the chapter.
>>>>>>> bb2bfe4b083eae865dbfbf6d8b88eaa174851e73
