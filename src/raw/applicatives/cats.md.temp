## Using Applicatives in Cats

Now we have a firm understanding of the semantics of applicatives,
let's look at some of the useful methods and syntax we can use in Cats.

The applicative type class is [`cats.Applicative`][cats.Applicative].
`Applicative` extends `Apply`, which is where the `ap` method is defined.
`Applicative` itself defines `point` as we saw in the discussion of
[the `Monad` type class](#monad-type-class).

### Obtaining Instances

As usual, we obtain instances via `Applicative.apply`:

```tut:book
import cats.Applicative
import cats.std.option._
import cats.std.list._

val inc = (x: Int) => x + 2

Applicative[Option].ap(Some(inc))(Some(1))
```

In addition to `ap` and `point`, `Applicative` defines several helper methods. The `ap2` through `ap22` methods provide nested calls to `ap` for functions of 2 to 8 arguments:

```tut:book
val sum3 = (a: Int, b: Int, c: Int) => a + b + c

Applicative[Option].ap3(Some(sum3))(Some(1), Some(2), Some(3))
```

<!--
TODO: Applicative extends Functor. Maybe move these later?

In additionn, `map` through `map22` provide versions of `ap` that work with an unwrapped function parameters:

```tut:book:fail
Applicative[Option].map3(Some(1), Some(2), Some(3))(sum3)
```
-->

<!--
TODO: Not present in Cats?

The `lift` through `lift12` methods lift functions into the relevant applicative:

```tut:book:fail
val optSum3 = Applicative[Option].lift3(sum3)

optSum3(Some(1), Some(2), Some(3))
```
-->

Finally, the `sequence` method described in [the monads chapter](#monad-type-class) is also available on `Applicative`:

```tut:book
val sequence: Option[List[Int]] =
  Applicative[Option].sequence(List(Option(1), Option(2), Option(3)))
```

### Applicative Builder Syntax

Cats provides a special *applicative builder* syntax to make using `apply2` and so on more convenient to use. Here's an example:

```tut:book
import cats.syntax.applicative._

def readInt(str: String): Validated[List[String], Int] =
  str.parseInt.leftMap(_ => List(s"Couldn't read $str"))

val readAllInts = (
  readInt("123") |@|
  readInt("bar") |@|
  readInt("baz")
)(_ + _ + _)
```

`|@|` is an enriched method provided via `cats.syntax.applicative` that creates an `ApplicativeBuilder`. This is an object that has an `apply` method that behaves like `Applicative.apply2`:

```tut:book
readInt("123") |@| readInt("456")

res5.apply(sum2)
```

In addition to `apply`, `ApplicativeBuilder` has another `|@|` method that builds a new builder for three arguments:

```tut:book
readInt("123") |@| readInt("456") |@| readInt("789")

res7.apply(sum3)
```

As you have probably guessed, the three-argument builder has an `apply` method that behaves like `apply3` and a `|@|` method to produce a four-argument builder... and so on up to 12 arguments. This system makes it incredibly easy to lift a function of multiple arguments into the context of an `Applicative`. The syntax is:

```tut:book
(
  wrappedArg1 |@|
  wrappedArg2 |@|
  wrappedArg3 |@|
  ...
) {
  (arg1, arg2, arg3, ...) =>
    resultExpression
}
```

Each builder also has a `tupled` method to quickly combine the results into a tuple:

```tut:book
(
  readInt("123") |@|
  readInt("234") |@|
  readInt("345")
).tupled
```

### Exercise

<div class="callout callout-danger">
  TODO: Applicative builder exercises!
</div>
